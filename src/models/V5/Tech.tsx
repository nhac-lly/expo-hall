/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 .\tech.gltf --shadows --types 
*/

import * as THREE from "three";
import React, { JSX, useRef, useState, useEffect } from "react";
import { useLoader } from "@react-three/fiber";
import { GLTFLoader } from "three-stdlib";
import { GLTF } from "three-stdlib";
import { useThree, useFrame } from "@react-three/fiber";

type GLTFResult = GLTF & {
  scene: THREE.Scene;
  nodes: {
    [key: string]: THREE.Object3D;
  };
  materials: {
    [key: string]: THREE.Material;
  };
};

export function TechModel(props: JSX.IntrinsicElements["group"]) {
  const gltf = useLoader(
    GLTFLoader,
    "/V4/TECH_LOD/tech.gltf"
  ) as unknown as GLTFResult;
  const { camera } = useThree();
  const [lodLevel, setLodLevel] = useState(0);
  const groupRef = useRef<THREE.Group>(null);
  const meshesRef = useRef<Map<string, THREE.Mesh>>(new Map());

  // Initialize meshes map and set up disposal
  useEffect(() => {
    const meshes = new Map<string, THREE.Mesh>();

    // Collect all meshes from the scene
    gltf.scene.traverse((child: THREE.Object3D) => {
      if (child instanceof THREE.Mesh) {
        meshes.set(child.name, child);
        // Initially hide all meshes
        child.visible = false;
      }
    });

    meshesRef.current = meshes;

    // Cleanup function
    return () => {
      meshes.forEach((mesh) => {
        if (mesh.geometry) mesh.geometry.dispose();
        if (mesh.material) {
          if (Array.isArray(mesh.material)) {
            mesh.material.forEach((m) => m.dispose());
          } else {
            mesh.material.dispose();
          }
        }
      });
      meshes.clear();
    };
  }, [gltf]);

  // Function to update mesh visibility based on LOD level
  const updateLODVisibility = (level: number) => {
    meshesRef.current.forEach((mesh, name) => {
      // Show meshes that belong to the current LOD level or lower
      const meshLevel = parseInt(name.split("_l")[1]?.split("_")[0] || "0");
      mesh.visible = meshLevel <= level;
    });
  };

  useFrame(() => {
    if (groupRef.current) {
      const worldPos = new THREE.Vector3();
      groupRef.current.getWorldPosition(worldPos);
      const distance = camera.position.distanceTo(worldPos);
      const newLodLevel =
        distance <= 12
          ? 4
          : distance <= 15
          ? 3
          : distance <= 20
          ? 2
          : distance <= 25
          ? 1
          : 0;

      if (newLodLevel !== lodLevel) {
        updateLODVisibility(newLodLevel);
        setLodLevel(newLodLevel);
      }
    }
  });

  return (
    <group {...props} dispose={null} ref={groupRef}>
      <primitive object={gltf.scene} />
    </group>
  );
}
